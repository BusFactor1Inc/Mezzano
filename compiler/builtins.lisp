;;;; Copyright (c) 2011-2015 Henry Harrington <henry.harrington@gmail.com>
;;;; This code is licensed under the MIT license.

;;;; Functions which are built in to the compiler and have custom code generators.

(in-package :sys.c)

(defparameter *builtins* (make-hash-table :test #'equal))

(defun small-fixnum-p (integer)
  (typep integer `(signed-byte ,(- 32 sys.int::+fixnum-tag-mask+))))

(defmacro defbuiltin (name lambda-list (&optional (emit-function t) suppress-binding-stack-check) &body body)
  `(progn (setf (gethash ',name *builtins*)
		(list ',lambda-list
		      (lambda ,lambda-list
			(declare (system:lambda-name ,name)
                                 ,@(when suppress-binding-stack-check
                                     '((sys.int::suppress-ssp-checking))))
			,@body)
                      ',emit-function
                      ',name
                      ',suppress-binding-stack-check))
	  ',name))

(defun emit-tag-check (reg tag type)
  "Emit a value tag type check. Smashes AL."
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error reg type))
    (emit `(sys.lap-x86:mov8 :al ,(sys.lap-x86::convert-width reg 8))
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,tag)
          `(sys.lap-x86:jne ,type-error-label))))

(defun emit-object-type-check (reg object-tag type original)
  "Emit an object tag type check. Smashes AL."
  (unless (and (quoted-constant-p original)
             (typep (second original) type))
    (let ((type-error-label (gensym)))
      (emit-trailer (type-error-label)
        (raise-type-error reg type))
      (emit `(sys.lap-x86:mov8 :al ,(sys.lap-x86::convert-width reg 8))
            `(sys.lap-x86:and8 :al #b1111)
            `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov8 :al (,reg ,(- sys.int::+tag-object+)))
            `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
            `(sys.lap-x86:cmp8 :al ,(ash object-tag sys.int::+array-type-shift+))
            `(sys.lap-x86:jne ,type-error-label)))))

(defmacro define-reader (name type tag slot)
  `(defbuiltin ,name (object) ()
     (load-in-reg :r8 object t)
     (smash-r8)
     (emit-tag-check :r8 ,tag ',type)
     (emit `(sys.lap-x86:mov64 :r8 (,',slot :r8)))
     (setf *r8-value* (list (gensym)))))

(defmacro define-writer (name type tag slot)
  `(defbuiltin ,name (value object) ()
     (load-in-reg :r9 object t)
     (load-in-reg :r8 value t)
     (emit-tag-check :r9 ,tag ',type)
     (emit `(sys.lap-x86:mov64 (,',slot :r9) :r8))
     *r8-value*))

(defmacro define-accessor (name type tag slot)
  `(progn (define-reader ,name ,type ,tag ,slot)
          (define-writer (setf ,name) ,type ,tag ,slot)))

(defmacro define-tag-type-predicate (name tag)
  `(defbuiltin ,name (object) ()
     (load-in-reg :r8 object t)
     (emit `(sys.lap-x86:mov8 :al :r8l)
           `(sys.lap-x86:and8 :al #b1111)
           `(sys.lap-x86:cmp8 :al ,,tag))
     (predicate-result :e)))

(defmacro define-array-like-predicate (name array-type)
  `(defbuiltin ,name (object) ()
     (let ((out (gensym)))
       (load-in-reg :r9 object t)
       (smash-r8)
       ;; Check tag.
       (emit `(sys.lap-x86:mov8 :al :r9l)
             `(sys.lap-x86:and8 :al #b1111)
             `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
             `(sys.lap-x86:jne ,out)
             `(sys.lap-x86:mov8 :al ,(object-ea :r9 :slot -1))
             `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                          sys.int::+array-type-shift+))
             `(sys.lap-x86:cmp8 :al ,(ash ,array-type sys.int::+array-type-shift+))
             ;; Subtle. OUT can be reached through either the tag check
             ;; or through the array type check. Both checks clear ZF when
             ;; they fail.
             out)
       (predicate-result :z))))

(defmacro define-array-like-reader (name type-name array-type slot)
  `(defbuiltin ,name (object) ()
     (load-in-reg :r8 object t)
     (smash-r8)
     (emit-object-type-check :r8 ,array-type ',type-name object)
     ;; Load.
     (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot ,slot)))
     (setf *r8-value* (list (gensym)))))

(defmacro define-array-like-writer (name type-name array-type slot)
  `(defbuiltin ,name (value object) ()
     (load-in-reg :r9 object t)
     (load-in-reg :r8 value t)
     (emit-object-type-check :r9 ,array-type ',type-name object)
     ;; Store.
     (emit `(sys.lap-x86:mov64 ,(object-ea :r9 :slot ,slot) :r8))
     *r8-value*))

(defmacro define-array-like-accessor (name type-name array-type slot)
  `(progn (define-array-like-reader ,name ,type-name ,array-type ,slot)
          (define-array-like-writer (setf ,name) ,type-name ,array-type ,slot)))

;; Produce an alist of symbol names and their associated functions.
(defun generate-builtin-functions ()
  (let ((functions '()))
    (maphash (lambda (symbol info)
               (declare (ignore symbol))
               (when (third info)
                 (push (list (fourth info)
                             `(lambda ,(first info)
                                (declare (system:lambda-name ,(fourth info)))
                                (funcall #',(fourth info) ,@(first info))))
                       functions)))
             *builtins*)
    functions))

(defun match-builtin (symbol arg-count)
  (let ((x (gethash symbol *builtins*)))
    (when (and x (eql (length (first x)) arg-count))
      (second x))))

(defun quoted-constant-p (tag)
  (and (consp tag)
       (consp (cdr tag))
       (null (cddr tag))
       (eql (first tag) 'quote)))

(defun constant-type-p (tag type)
  (and (quoted-constant-p tag)
       (typep (second tag) type)))

(defun box-unsigned-byte-64-rax ()
  "Box the unboxed (unsigned-byte 64) in RAX into R8."
  (let ((overflow-label (gensym))
        (resume (gensym)))
    (emit-trailer (overflow-label)
      (emit
       ;; Undo the shift.
       `(sys.lap-x86:rcr64 :rax 1)
       ;; Prod the sign flag.
       `(sys.lap-x86:test64 :rax :rax)
       ;; Build bignum.
       `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
       ;; Result needs a 128-bit bignum when the high bit is set.
       `(sys.lap-x86:cmov64s :r13 (:function sys.int::%%make-bignum-128-rdx-rax))
       `(sys.lap-x86:xor32 :edx :edx)
       `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
       `(sys.lap-x86:jmp ,resume)))
    (smash-r8)
    (emit
     ;; Convert to fixnum & check for unsigned overflow.
     ;; Assumes fixnum size of 1!
     `(sys.lap-x86:shl64 :rax 1)
     `(sys.lap-x86:jc ,overflow-label)
     `(sys.lap-x86:js ,overflow-label)
     `(sys.lap-x86:mov64 :r8 :rax)
     resume)))

(defmacro define-u-b-memref (name width read-op write-op register)
  `(progn
     (defbuiltin ,name (base offset) ()
       (load-in-reg :r9 base t)
       (fixnum-check :r9)
       (emit `(sys.lap-x86:mov64 :rdx :r9))
       (load-in-reg :r9 offset t)
       (fixnum-check :r9)
       (emit `(sys.lap-x86:mov64 :rcx :r9))
       (smash-r8)
       ;; BASE to raw integer.
       (emit '(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+))
       ;; Convert OFFSET to a raw integer.
       (emit '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+))
       ;; Read
       (emit '(,read-op :eax (:rdx (:rcx ,width))))
       ;; Convert to fixnum.
       (emit '(sys.lap-x86:lea64 :r8 ((:rax ,(ash 1 sys.int::+n-fixnum-bits+)))))
       (setf *r8-value* (list (gensym))))
     (defbuiltin (setf ,name) (new-value base offset) ()
       (let ((type-error-label (gensym)))
         (emit-trailer (type-error-label)
           (raise-type-error :r8 '(unsigned-byte ,(* width 8))))
         (load-in-reg :r9 base t)
         (fixnum-check :r9)
         (emit `(sys.lap-x86:mov64 :rdx :r9))
         (load-in-reg :r9 offset t)
         (fixnum-check :r9)
         (emit `(sys.lap-x86:mov64 :rcx :r9))
         (load-in-r8 new-value t)
         (emit '(sys.lap-x86:mov64 :rax :r8)
               '(sys.lap-x86:test64 :rax ,sys.int::+fixnum-tag-mask+)
               `(sys.lap-x86:jnz ,type-error-label)
               '(sys.lap-x86:mov64 :rsi ,(fixnum-to-raw (ash 1 (* width 8))))
               '(sys.lap-x86:cmp64 :rax :rsi)
               `(sys.lap-x86:jae ,type-error-label)
               ;; Convert to raw integers.
               '(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
               '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
               '(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
               ;; Write.
               '(,write-op (:rdx (:rcx ,width)) ,register))
         *r8-value*))))

(define-u-b-memref sys.int::memref-unsigned-byte-8 1 sys.lap-x86:movzx8 sys.lap-x86:mov8 :al)
(define-u-b-memref sys.int::memref-unsigned-byte-16 2 sys.lap-x86:movzx16 sys.lap-x86:mov16 :ax)
(define-u-b-memref sys.int::memref-unsigned-byte-32 4 sys.lap-x86:mov32 sys.lap-x86:mov32 :eax)

(defbuiltin sys.int::memref-unsigned-byte-64 (base offset) ()
  (load-in-reg :r8 base t)
  (fixnum-check :r8)
  (load-in-reg :r9 offset t)
  (fixnum-check :r9)
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :rax :r8)
        `(sys.lap-x86:mov64 :rcx :r9)
        ;; Convert to raw integers.
        `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
          ;; Read.
        `(sys.lap-x86:mov64 :rax (:rax (:rcx 8))))
  (box-unsigned-byte-64-rax)
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::memref-unsigned-byte-64) (new-value base offset) ()
  (let ((type-error-label (gensym))
        (bignum-path (gensym "mr-ub64-bignum"))
        (len-2-bignum (gensym "mr-ub64-len-2-bignum"))
        (value-extracted (gensym "mr-ub64-value-extracted")))
    (emit-trailer (bignum-path)
      ;; Check for bignumness.
      (emit `(sys.lap-x86:and8 :dl #b1111)
            `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-object+)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot -1))
            `(sys.lap-x86:and8 :dl ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:cmp8 :dl ,(ash sys.int::+object-tag-bignum+
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:shr64 :rdx 8)
            ;; RDX = bignum length.
            `(sys.lap-x86:cmp64 :rdx 2)
            `(sys.lap-x86:je ,len-2-bignum)
            ;; Not length 2, must be length 1.
            `(sys.lap-x86:cmp64 :rdx 1)
            `(sys.lap-x86:jne ,type-error-label)
            ;; And the sign bit must be clear.
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
            `(sys.lap-x86:shl64 :rdx 1)
            `(sys.lap-x86:jc ,type-error-label)
            `(sys.lap-x86:rcr64 :rdx 1)
            `(sys.lap-x86:jmp ,value-extracted)
            len-2-bignum
            ;; Length 2 bignums must have the high word be 0.
            `(sys.lap-x86:cmp64 ,(object-ea :r8 :slot 1) 0)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
            `(sys.lap-x86:jmp ,value-extracted)
            type-error-label)
      (raise-type-error :r8 '(unsigned-byte 64)))
    (load-in-reg :r9 base t)
    (fixnum-check :r9)
    (emit `(sys.lap-x86:mov64 :rax :r9))
    (load-in-reg :r9 offset t)
    (fixnum-check :r9)
    (emit `(sys.lap-x86:mov64 :rcx :r9))
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
	  `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
          `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx ,sys.int::+fixnum-tag-mask+)
	  `(sys.lap-x86:jnz ,bignum-path)
          `(sys.lap-x86:cmp64 :r8 0)
          `(sys.lap-x86:jl ,type-error-label)
	  ;; Convert to raw integers.
	  `(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
          value-extracted
	  ;; Write.
	  `(sys.lap-x86:mov64 (:rax (:rcx 8)) :rdx))
    *r8-value*))

(defmacro define-s-b-memref (name width read-op write-op register)
  `(progn
     (defbuiltin ,name (base offset) ()
       (load-in-reg :r9 base t)
       (fixnum-check :r9)
       (emit `(sys.lap-x86:mov64 :rdx :r9))
       (load-in-reg :r9 offset t)
       (fixnum-check :r9)
       (emit `(sys.lap-x86:mov64 :rcx :r9))
       (smash-r8)
       ;; BASE & OFFSET to raw integer.
       (emit '(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
             '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+))
       ;; Read it.
       (emit '(,read-op :rax (:rdx (:rcx ,width))))
       ;; Convert to fixnum.
       (emit '(sys.lap-x86:lea64 :r8 ((:rax ,(ash 1 sys.int::+n-fixnum-bits+)))))
       (setf *r8-value* (list (gensym))))
     (defbuiltin (setf ,name) (new-value base offset) ()
       (let ((type-error-label (gensym)))
         (emit-trailer (type-error-label)
           (raise-type-error :r8 '(signed-byte ,(* width 8))))
         (load-in-reg :r9 base t)
         (fixnum-check :r9)
         (emit `(sys.lap-x86:mov64 :rdx :r9))
         (load-in-reg :r9 offset t)
         (fixnum-check :r9)
         (emit `(sys.lap-x86:mov64 :rcx :r9))
         (load-in-r8 new-value t)
         (emit '(sys.lap-x86:mov64 :rax :r8)
               '(sys.lap-x86:test64 :rax ,sys.int::+fixnum-tag-mask+)
               `(sys.lap-x86:jnz ,type-error-label)
               '(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
               '(sys.lap-x86:mov64 :rsi :rax)
               '(sys.lap-x86:mov64 :rdi ,(ash 1 (1- (* width 8))))
               '(sys.lap-x86:cmp64 :rsi :rdi)
               `(sys.lap-x86:jge ,type-error-label)
               '(sys.lap-x86:mov64 :rdi ,(- (ash 1 (1- (* width 8)))))
               '(sys.lap-x86:cmp64 :rsi :rdi)
               `(sys.lap-x86:jl ,type-error-label)
               ;; Convert to raw integers.
               '(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
               '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
               ;; Write.
               '(,write-op (:rdx (:rcx ,width)) ,register))
         *r8-value*))))

(define-s-b-memref sys.int::memref-signed-byte-8 1 sys.lap-x86:movsx8 sys.lap-x86:mov8 :al)
(define-s-b-memref sys.int::memref-signed-byte-16 2 sys.lap-x86:movsx16 sys.lap-x86:mov16 :ax)
(define-s-b-memref sys.int::memref-signed-byte-32 4 sys.lap-x86:movsx32 sys.lap-x86:mov32 :eax)

(defbuiltin sys.int::memref-signed-byte-64 (base offset) ()
  (let ((overflow-label (gensym))
        (resume (gensym)))
    (emit-trailer (overflow-label)
      (emit `(sys.lap-x86:rcr64 :rax 1)
            `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r8 base t)
    (fixnum-check :r8)
    (load-in-reg :r9 offset t)
    (fixnum-check :r9)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:mov64 :rcx :r9)
	  ;; Convert to raw integers.
	  `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
	  `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
          ;; Read.
          `(sys.lap-x86:mov64 :rax (:rax (:rcx 8)))
          ;; Convert to fixnum & check for signed overflow.
          ;; Assumes fixnum size of 1!
          `(sys.lap-x86:shl64 :rax 1)
          `(sys.lap-x86:jo ,overflow-label)
          `(sys.lap-x86:mov64 :r8 :rax)
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::memref-signed-byte-64) (new-value base offset) ()
  (let ((type-error-label (gensym))
        (bignum-path (gensym "mr-sb64-bignum"))
        (value-extracted (gensym "mr-sb64-value-extracted")))
    (emit-trailer (bignum-path)
      ;; Check for bignumness.
      (emit `(sys.lap-x86:and8 :dl #b1111)
            `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-object+)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot -1))
            `(sys.lap-x86:and8 :dl ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:cmp8 :dl ,(ash sys.int::+object-tag-bignum+
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:jne ,type-error-label)
            ;; Length check.
            `(sys.lap-x86:cmp64 :rdx ,(ash 1 sys.int::+array-length-shift+))
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
            `(sys.lap-x86:jmp ,value-extracted)
            type-error-label)
      (raise-type-error :r8 '(signed-byte 64)))
    (load-in-reg :r9 base t)
    (fixnum-check :r9)
    (emit `(sys.lap-x86:mov64 :rax :r9))
    (load-in-reg :r9 offset t)
    (fixnum-check :r9)
    (emit `(sys.lap-x86:mov64 :rcx :r9))
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx ,sys.int::+fixnum-tag-mask+)
	  `(sys.lap-x86:jnz ,bignum-path)
	  ;; Convert to raw integers
	  `(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
          value-extracted
	  `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
	  `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
	  ;; Write.
	  `(sys.lap-x86:mov64 (:rax (:rcx 8)) :rdx))
    *r8-value*))

(defbuiltin sys.int::memref-t (base offset) ()
  (load-in-reg :r9 base t)
  (fixnum-check :r9)
  (emit `(sys.lap-x86:mov64 :rax :r9))
  (load-in-reg :r9 offset t)
  (fixnum-check :r9)
  (emit `(sys.lap-x86:mov64 :rcx :r9))
  (smash-r8)
  (emit ;; Convert to raw integers.
   `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
   `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
   ;; Read.
   `(sys.lap-x86:mov64 :r8 (:rax (:rcx 8))))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::memref-t) (new-value base offset) ()
  (load-in-reg :r9 base t)
  (fixnum-check :r9)
  (emit `(sys.lap-x86:mov64 :rax :r9))
  (load-in-reg :r9 offset t)
  (fixnum-check :r9)
  (emit `(sys.lap-x86:mov64 :rcx :r9))
  (load-in-r8 new-value t)
  (emit ;; Convert to raw integers.
   `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
   `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
   ;; Write.
   `(sys.lap-x86:mov64 (:rax (:rcx 8)) :r8))
  *r8-value*)

(defmacro define-u-b-alref (name width read-op write-op register)
  `(progn
     (defbuiltin ,name (array offset) ()
       (load-in-reg :r9 array t)
       (load-in-reg :r10 offset t)
       (fixnum-check :r10)
       (emit `(sys.lap-x86:mov64 :rcx :r10))
       (smash-r8)
       ;; Convert OFFSET to a raw integer & read it.
       (emit '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
             '(,read-op :eax ,(object-ea :r9 :index `(:rcx ,width))))
       ;; Convert to fixnum.
       (emit '(sys.lap-x86:lea64 :r8 ((:rax ,(ash 1 sys.int::+n-fixnum-bits+)))))
       (setf *r8-value* (list (gensym))))
     (defbuiltin (setf ,name) (new-value array offset) ()
       (let ((type-error-label (gensym)))
         (emit-trailer (type-error-label)
           (raise-type-error :r8 '(unsigned-byte ,(* width 8))))
         (load-in-reg :r9 array t)
         (load-in-reg :r10 offset t)
         (fixnum-check :r10)
         (emit `(sys.lap-x86:mov64 :rcx :r10))
         (load-in-r8 new-value t)
         (emit '(sys.lap-x86:mov64 :rax :r8)
               '(sys.lap-x86:test64 :rax ,sys.int::+fixnum-tag-mask+)
               `(sys.lap-x86:jnz ,type-error-label)
               '(sys.lap-x86:mov64 :rsi ,(fixnum-to-raw (ash 1 (* width 8))))
               '(sys.lap-x86:cmp64 :rax :rsi)
               `(sys.lap-x86:jae ,type-error-label)
               ;; Convert to raw integers.
               '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
               '(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
               ;; Write.
               '(,write-op ,(object-ea :r9 :index `(:rcx ,width)) ,register))
         *r8-value*))))

(define-u-b-alref sys.int::%array-like-ref-unsigned-byte-8  1 sys.lap-x86:movzx8  sys.lap-x86:mov8  :al)
(define-u-b-alref sys.int::%array-like-ref-unsigned-byte-16 2 sys.lap-x86:movzx16 sys.lap-x86:mov16 :ax)
(define-u-b-alref sys.int::%array-like-ref-unsigned-byte-32 4 sys.lap-x86:mov32   sys.lap-x86:mov32 :eax)

(defbuiltin sys.int::%array-like-ref-unsigned-byte-64 (array offset) ()
  (load-in-reg :r8 array t)
  (load-in-reg :r9 offset t)
  (fixnum-check :r9)
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :rcx :r9)
        ;; Convert to raw integers.
        `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
        ;; Read.
        `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :index `(:rcx 8))))
  (box-unsigned-byte-64-rax)
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::%array-like-ref-unsigned-byte-64) (new-value array offset) ()
  (let ((type-error-label (gensym))
        (bignum-path (gensym "alr-ub64-bignum"))
        (len-2-bignum (gensym "alr-ub64-len-2-bignum"))
        (value-extracted (gensym "alr-ub64-value-extracted")))
    (emit-trailer (bignum-path)
      ;; Check for bignumness.
      (emit `(sys.lap-x86:and8 :dl #b1111)
            `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-object+)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot -1))
            `(sys.lap-x86:and8 :dl ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:cmp8 :dl ,(ash sys.int::+object-tag-bignum+
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:shr64 :rdx ,sys.int::+array-length-shift+)
            ;; RDX = bignum length.
            `(sys.lap-x86:cmp64 :rdx 2)
            `(sys.lap-x86:je ,len-2-bignum)
            ;; Not length 2, must be length 1.
            `(sys.lap-x86:cmp64 :rdx 1)
            `(sys.lap-x86:jne ,type-error-label)
            ;; And the sign bit must be clear.
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
            `(sys.lap-x86:shl64 :rdx 1)
            `(sys.lap-x86:jc ,type-error-label)
            `(sys.lap-x86:rcr64 :rdx 1)
            `(sys.lap-x86:jmp ,value-extracted)
            len-2-bignum
            ;; Length 2 bignums must have the high word be 0.
            `(sys.lap-x86:cmp64 ,(object-ea :r8 :slot 1) 0)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
            `(sys.lap-x86:jmp ,value-extracted)
            type-error-label)
      (raise-type-error :r8 '(unsigned-byte 64)))
    (load-in-reg :r9 array t)
    (load-in-reg :r10 offset t)
    (fixnum-check :r10)
    (emit `(sys.lap-x86:mov64 :rcx :r10))
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx ,sys.int::+fixnum-tag-mask+)
	  `(sys.lap-x86:jnz ,bignum-path)
          `(sys.lap-x86:cmp64 :r8 0)
          `(sys.lap-x86:jl ,type-error-label)
	  ;; Convert to raw integer.
	  `(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
          value-extracted
	  `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
	  ;; Write.
	  `(sys.lap-x86:mov64 ,(object-ea :r9 :index '(:rcx 8)) :rdx))
    *r8-value*))

(defmacro define-s-b-alref (name width read-op write-op register)
  `(progn
     (defbuiltin ,name (array offset) ()
       (load-in-reg :r9 array t)
       (load-in-reg :r10 offset t)
       (fixnum-check :r10)
       (emit `(sys.lap-x86:mov64 :rcx :r10))
       (smash-r8)
       ;; Convert OFFSET to a raw integer & read it.
       (emit '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
             '(,read-op :rax ,(object-ea :r9 :index `(:rcx ,width))))
       ;; Convert to fixnum.
       (emit '(sys.lap-x86:lea64 :r8 ((:rax ,(ash 1 sys.int::+n-fixnum-bits+)))))
       (setf *r8-value* (list (gensym))))
     (defbuiltin (setf ,name) (new-value array offset) ()
       (let ((type-error-label (gensym)))
         (emit-trailer (type-error-label)
           (raise-type-error :r8 '(signed-byte ,(* width 8))))
         (load-in-reg :r9 array t)
         (load-in-reg :r10 offset t)
         (fixnum-check :r10)
         (emit `(sys.lap-x86:mov64 :rcx :r10))
         (load-in-r8 new-value t)
         (emit '(sys.lap-x86:mov64 :rax :r8)
               '(sys.lap-x86:test64 :rax ,sys.int::+fixnum-tag-mask+)
               `(sys.lap-x86:jnz ,type-error-label)
               '(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
               '(sys.lap-x86:mov64 :rsi :rax)
               '(sys.lap-x86:mov64 :rdi ,(ash 1 (1- (* width 8))))
               '(sys.lap-x86:cmp64 :rsi :rdi)
               `(sys.lap-x86:jge ,type-error-label)
               '(sys.lap-x86:mov64 :rdi ,(- (ash 1 (1- (* width 8)))))
               '(sys.lap-x86:cmp64 :rsi :rdi)
               `(sys.lap-x86:jl ,type-error-label)
               ;; Convert to raw integer.
               '(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
               ;; Write.
               '(,write-op ,(object-ea :r9 :index `(:rcx ,width)) ,register))
         *r8-value*))))

(define-s-b-alref sys.int::%array-like-ref-signed-byte-8  1 sys.lap-x86:movsx8  sys.lap-x86:mov8  :al)
(define-s-b-alref sys.int::%array-like-ref-signed-byte-16 2 sys.lap-x86:movsx16 sys.lap-x86:mov16 :ax)
(define-s-b-alref sys.int::%array-like-ref-signed-byte-32 4 sys.lap-x86:movsx32 sys.lap-x86:mov32 :eax)

(defbuiltin sys.int::%array-like-ref-signed-byte-64 (array offset) ()
  (let ((overflow-label (gensym))
        (resume (gensym)))
    (emit-trailer (overflow-label)
      (emit `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r8 array t)
    (load-in-reg :r9 offset t)
    (fixnum-check :r9)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :rcx :r9)
          `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
          ;; Read.
          `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :index '(:rcx 8)))
          ;; Convert to fixnum & check for signed overflow.
          ;; Assumes fixnum size of 1!
          `(sys.lap-x86:shl64 :rax 1)
          `(sys.lap-x86:jo ,overflow-label)
          `(sys.lap-x86:mov64 :r8 :rax)
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::%array-like-ref-signed-byte-64) (new-value array offset) ()
  (let ((type-error-label (gensym))
        (bignum-path (gensym "alr-sb64-bignum"))
        (value-extracted (gensym "alr-sb64-value-extracted")))
    (emit-trailer (bignum-path)
      ;; Check for bignumness.
      (emit `(sys.lap-x86:and8 :dl #b1111)
            `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-object+)
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot -1))
            `(sys.lap-x86:and8 :dl ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:cmp8 :dl ,(ash sys.int::+object-tag-bignum+
                                         sys.int::+array-type-shift+))
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:cmp64 :rdx ,(ash 1 sys.int::+array-length-shift+))
            `(sys.lap-x86:jne ,type-error-label)
            `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
            `(sys.lap-x86:jmp ,value-extracted)
            type-error-label)
      (raise-type-error :r8 '(signed-byte 64)))
    (load-in-reg :r9 array t)
    (load-in-reg :r10 offset t)
    (fixnum-check :r10)
    (emit `(sys.lap-x86:mov64 :rcx :r10))
    (load-in-r8 new-value t)
    (emit `(sys.lap-x86:mov64 :rdx :r8)
	  `(sys.lap-x86:test64 :rdx ,sys.int::+fixnum-tag-mask+)
	  `(sys.lap-x86:jnz ,bignum-path)
	  ;; Convert to raw integer.
	  `(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
          value-extracted
	  `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
	  ;; Write.
	  `(sys.lap-x86:mov64 ,(object-ea :r9 :index '(:rcx 8)) :rdx))
    *r8-value*))

(defbuiltin sys.int::%array-like-ref-t (array offset) ()
  (load-in-reg :r8 array t)
  (load-in-reg :r9 offset t)
  (fixnum-check :r9)
  (emit `(sys.lap-x86:mov64 :rcx :r9)
        `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+))
  (smash-r8)
  ;; Read.
  (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :index '(:rcx 8))))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::%array-like-ref-t) (new-value array offset) ()
  (load-in-reg :r9 array t)
  (load-in-reg :r10 offset t)
  (fixnum-check :r10)
  (emit `(sys.lap-x86:mov64 :rcx :r10)
        `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+))
  (load-in-r8 new-value t)
  ;; Write.
  (emit `(sys.lap-x86:mov64 ,(object-ea :r9 :index '(:rcx 8)) :r8))
  *r8-value*)

;; Add DELTA to the slot at OFFSET in OBJECT.
;; Returns the old value of the slot.
(defbuiltin sys.int::%atomic-fixnum-add-array-like (object offset delta) ()
  (load-in-reg :r10 offset t)
  (fixnum-check :r10)
  (load-in-reg :r9 object t)
  (load-in-reg :r8 delta t)
  (fixnum-check :r8)
  (smash-r8)
  (emit
   ;; Convert slot number to integers.
   `(sys.lap-x86:mov64 :rcx :r10)
   `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
   ;; Atomic add.
   `(sys.lap-x86:lock)
   `(sys.lap-x86:xadd64 ,(object-ea :r9 :index '(:rcx 8)) :r8))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%xchg-array-like (object offset new) ()
  (load-in-reg :r10 offset t)
  (fixnum-check :r10)
  (load-in-reg :r9 object t)
  (load-in-reg :r8 new t)
  (smash-r8)
  (emit
   ;; Convert slot number to integers.
   `(sys.lap-x86:mov64 :rcx :r10)
   `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
   ;; Do the swap. xchg has an implicit lock prefix.
   `(sys.lap-x86:xchg64 ,(object-ea :r9 :index '(:rcx 8)) :r8))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%cas-array-like (object offset old new) ()
  (load-in-reg :r10 offset t)
  (fixnum-check :r10)
  (load-in-reg :r9 object t)
  (load-in-reg :r11 new t)
  (load-in-reg :r8 old t)
  (smash-r8)
  (emit
   ;; Convert size and slot number to integers.
   `(sys.lap-x86:mov64 :rcx :r10)
   `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
   `(sys.lap-x86:mov64 :rax :r8))
  (emit-gc-info :extra-registers :rax)
  (emit
   `(sys.lap-x86:lock)
   `(sys.lap-x86:cmpxchg ,(object-ea :r9 :index '(:rcx 8)) :r11))
  (cond ((member *for-value* '(:multiple :tail))
         ;; Return success and the old value.
         (emit `(sys.lap-x86:mov64 :r9 :rax))
         (emit-gc-info)
         (emit `(sys.lap-x86:mov64 :r8 nil)
               `(sys.lap-x86:cmov64z :r8 (:constant t)))
         (load-constant :rcx 2)
         :multiple)
        (t ;; Just return the success state.
         (emit-gc-info)
         (predicate-result :z))))

(defbuiltin sys.int::%dcas-array-like (object offset old-1 old-2 new-1 new-2) ()
  (load-in-reg :r10 offset t)
  (fixnum-check :r10)
  (load-in-reg :r8 object t)
  ;; Carefully load registers to avoid exposing the GC to a raw value.
  (load-in-reg :rbx new-1 t) ; rbx loaded (rbx is a value register).
  (load-in-reg :rax old-1 t) ; rbx, rax loaded.
  (emit-gc-info :extra-registers :rax)
  (load-in-reg :rcx new-2 t) ; rbx, rax, rcx loaded.
  (emit-gc-info :extra-registers :rax-rcx)
  (load-in-reg :rdx old-2 t) ; all registers loaded.
  (emit-gc-info :extra-registers :rax-rcx-rdx)
  (smash-r8)
  (emit
   ;; Convert size and slot number to integers.
   `(sys.lap-x86:mov64 :rdi :r10)
   `(sys.lap-x86:shr64 :rdi ,sys.int::+n-fixnum-bits+)
   `(sys.lap-x86:lock)
   `(sys.lap-x86:cmpxchg16b ,(object-ea :r8 :index '(:rdi 8))))
  (cond ((member *for-value* '(:multiple :tail))
         ;; Return status and the old values.
         (emit `(sys.lap-x86:mov64 :r9 :rax))
         (emit `(sys.lap-x86:mov64 :r10 :rdx))
         (emit-gc-info)
         (emit `(sys.lap-x86:mov64 :r8 nil)
               `(sys.lap-x86:cmov64z :r8 (:constant t)))
         (load-constant :rcx 3)
         :multiple)
        (t ;; Just return the status.
         (emit-gc-info)
         (predicate-result :z))))

(defbuiltin sys.int::%simple-1d-array-p (object) ()
  (let ((false-out (gensym))
        (out (gensym)))
    (load-in-reg :r8 object t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,false-out)
          `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+last-simple-1d-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:jnbe ,false-out)
          `(sys.lap-x86:mov64 :r8 t)
          `(sys.lap-x86:jmp ,out)
          false-out
          `(sys.lap-x86:mov64 :r8 nil)
          out)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%simple-1d-array-length (array) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 '(simple-array * (*))))
    (load-in-r8 array t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Ensure that it is a simple-array, not a struct or bignum or similar.
	  `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
	  `(sys.lap-x86:cmp8 :al ,(ash sys.int::+last-simple-1d-array-object-tag+
                                       sys.int::+array-type-shift+))
	  `(sys.lap-x86:jnbe ,type-error-label)
	  ;; Convert length to fixnum.
	  `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
          `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
	  `(sys.lap-x86:mov64 :r8 :rax))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%simple-array-type (array) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 '(simple-array * (*))))
    (load-in-r8 array t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Ensure that it is a simple-array, not a struct or bignum or similar.
	  `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
	  `(sys.lap-x86:cmp8 :al ,(ash sys.int::+last-simple-1d-array-object-tag+
                                       sys.int::+array-type-shift+))
	  `(sys.lap-x86:jnbe ,type-error-label)
	  ;; Convert tag to fixnum. Low 3 bits are for the GC, always clear.
          `(sys.lap-x86:and32 :eax ,(ash (- (ash 1 sys.int::+array-type-size+) 1) sys.int::+array-type-shift+))
	  `(sys.lap-x86:shr32 :eax ,sys.int::+array-type-shift+)
          `(sys.lap-x86:shl32 :eax ,sys.int::+n-fixnum-bits+)
	  `(sys.lap-x86:mov32 :r8d :eax))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-logior (x y) ()
  (let ((full-logior (gensym))
        (resume (gensym)))
    (when (constant-type-p y 'fixnum)
      (rotatef x y))
    (emit-trailer (full-logior)
      (when (constant-type-p x 'fixnum)
        (load-constant :r9 (second x)))
      (call-support-function 'sys.int::generic-logior 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (cond ((constant-type-p x 'fixnum)
           (load-in-r8 y t)
           (smash-r8)
           (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                 `(sys.lap-x86:jnz ,full-logior))
           ;; Small integers can be encoded directly into the instruction.
           (if (small-fixnum-p (second x))
               (emit `(sys.lap-x86:or64 :r8 ,(fixnum-to-raw (second x))))
               (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
                     `(sys.lap-x86:or64 :r8 :rax)))
           (emit resume)
           (setf *r8-value* (list (gensym))))
          (t (load-in-reg :r9 y t)
             (load-in-reg :r8 x t)
             (smash-r8)
             (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-logior)
                   `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-logior)
                   `(sys.lap-x86:or64 :r8 :r9)
                   resume)
             (setf *r8-value* (list (gensym)))))))

(defbuiltin sys.int::binary-logxor (x y) ()
  (let ((full-logxor (gensym))
        (resume (gensym)))
    (when (constant-type-p y 'fixnum)
      (rotatef x y))
    (emit-trailer (full-logxor)
      (when (constant-type-p x 'fixnum)
        (load-constant :r9 (second x)))
      (call-support-function 'sys.int::generic-logxor 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (cond ((constant-type-p x 'fixnum)
           (load-in-r8 y t)
           (smash-r8)
           (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                 `(sys.lap-x86:jnz ,full-logxor))
           ;; Small integers can be encoded directly into the instruction.
           (if (small-fixnum-p (second x))
               (emit `(sys.lap-x86:xor64 :r8 ,(fixnum-to-raw (second x))))
               (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
                     `(sys.lap-x86:xor64 :r8 :rax)))
           (emit resume)
           (setf *r8-value* (list (gensym))))
          (t (load-in-reg :r9 y t)
             (load-in-reg :r8 x t)
             (smash-r8)
             (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-logxor)
                   `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-logxor)
                   `(sys.lap-x86:xor64 :r8 :r9)
                   resume)
             (setf *r8-value* (list (gensym)))))))

(defbuiltin sys.int::binary-logand (x y) ()
  (let ((full-logand (gensym))
        (resume (gensym)))
    (when (constant-type-p y 'fixnum)
      (rotatef x y))
    (emit-trailer (full-logand)
      (when (constant-type-p x 'fixnum)
        (load-constant :r9 (second x)))
      (call-support-function 'sys.int::generic-logand 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (cond ((constant-type-p x 'fixnum)
           (load-in-r8 y t)
           (smash-r8)
           (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                 `(sys.lap-x86:jnz ,full-logand))
           ;; Small integers can be encoded directly into the instruction.
           (if (small-fixnum-p (second x))
               (emit `(sys.lap-x86:and64 :r8 ,(fixnum-to-raw (second x))))
               (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
                     `(sys.lap-x86:and64 :r8 :rax)))
           (emit resume)
           (setf *r8-value* (list (gensym))))
          (t (load-in-reg :r9 y t)
             (load-in-reg :r8 x t)
             (smash-r8)
             (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-logand)
                   `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-logand)
                   `(sys.lap-x86:and64 :r8 :r9)
                   resume)
             (setf *r8-value* (list (gensym)))))))

(defbuiltin lognot (integer) ()
  (let ((not-fixnum (gensym "lognot-other"))
        (resume (gensym "lognot-resume")))
    (emit-trailer (not-fixnum)
      (call-support-function 'sys.int::generic-lognot 1)
      (emit `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r8 integer t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,not-fixnum)
          `(sys.lap-x86:xor64 :r8 ,(- (ash 1 sys.int::+n-fixnum-bits+)))
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-+ (x y) ()
  (let ((ovfl (gensym "+ovfl"))
        (resume (gensym "+resume"))
        (full-add (gensym "+full")))
    (when (constant-type-p y 'fixnum)
      (rotatef x y))
    (emit-trailer (ovfl)
      ;; Recover the full value using the carry bit.
      (emit `(sys.lap-x86:mov64 :rax :r8)
            `(sys.lap-x86:rcr64 :rax 1))
      ;; Drop the remaining fixnum tag bits.
      ;(when (> sys.int::+n-fixnum-bits+ 1)
      ;  (emit `(sys.lap-x86:sar64 :rax ,(1- sys.int::+n-fixnum-bits+))))
      ;; Call assembly helper function.
      (emit `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:jmp ,resume)))
    (emit-trailer (full-add)
      (when (constant-type-p x 'fixnum)
        (load-constant :r9 (second x)))
      (call-support-function 'sys.int::generic-+ 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (cond ((constant-type-p x 'fixnum)
           (load-in-r8 y t)
           (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                 `(sys.lap-x86:jnz ,full-add))
           (smash-r8)
           ;; Small integers can be encoded directly into the instruction.
           (if (small-fixnum-p (second x))
               (emit `(sys.lap-x86:add64 :r8 ,(fixnum-to-raw (second x))))
               (emit `(sys.lap-x86:mov64 :rax ,(fixnum-to-raw (second x)))
                     `(sys.lap-x86:add64 :r8 :rax))))
          (t (load-in-reg :r9 y t)
             (load-in-reg :r8 x t)
             (emit `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-add)
                   `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full-add))
             (smash-r8)
             (emit `(sys.lap-x86:add64 :r8 :r9))))
    (emit `(sys.lap-x86:jo ,ovfl)
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-- (x y) ()
  (let ((ovfl (gensym "-ovfl"))
        (resume (gensym "-resume"))
        (full-sub (gensym "-full")))
    (emit-trailer (ovfl)
      ;; Recover the full value.
      (emit `(sys.lap-x86:cmc)
            `(sys.lap-x86:mov64 :rax :r8)
            `(sys.lap-x86:rcr64 :rax 1))
      ;; Drop the remaining fixnum tag bits.
      ;(when (> sys.int::+n-fixnum-bits+ 1)
      ;  (emit `(sys.lap-x86:sar64 :rax ,(1- sys.int::+n-fixnum-bits+))))
      ;; Call assembly helper function.
      (emit `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:jmp ,resume)))
    (emit-trailer (full-sub)
      (call-support-function 'sys.int::generic-- 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r8 x t)
    (load-in-reg :r9 y t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-sub)
          `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-sub)
          `(sys.lap-x86:sub64 :r8 :r9)
          `(sys.lap-x86:jo ,ovfl)
          resume)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::binary-* (x y) ()
  (let ((ovfl (gensym "*ovfl"))
        (resume (gensym "*resume"))
        (full-mul (gensym "*full"))
        (small-bignum (gensym "*small-result")))
    (emit-trailer (ovfl)
      ;; 128-bit result in rdx:rax.
      ;; Unbox the result.
      (emit `(sys.lap-x86:shrd64 :rax :rdx ,sys.int::+n-fixnum-bits+)
            `(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
            ;; Check if the result will fit in 64 bits.
            ;; Save the high bits.
            `(sys.lap-x86:mov64 :rcx :rdx)
            `(sys.lap-x86:cqo)
            `(sys.lap-x86:cmp64 :rcx :rdx)
            `(sys.lap-x86:je ,small-bignum)
            ;; Nope.
            `(sys.lap-x86:mov64 :rdx :rcx)
            `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-128-rdx-rax))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:jmp ,resume)
            small-bignum
            ;; Yup.
            `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:jmp ,resume)))
    (emit-trailer (full-mul)
      (call-support-function 'sys.int::generic-* 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r9 y t)
    (load-in-reg :r8 x t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-mul)
          `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-mul)
          `(sys.lap-x86:mov64 :rax :r8)
          ;; Convert RAX to raw integer, leaving R9 as a fixnum.
          ;; This will cause the result to be a fixnum.
          `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
          `(sys.lap-x86:imul64 :r9)
          `(sys.lap-x86:jo ,ovfl)
          ;; R9 was not converted to a raw integer, so the result
          ;; was automatically converted to a fixnum.
          `(sys.lap-x86:mov64 :r8 :rax)
          resume)
    (setf *r8-value* (list (gensym)))))

;; FIXME: default divisor to 1
(defbuiltin rem (number divisor) ()
  (let ((full-rem (gensym "full-rem"))
        (resume (gensym "resume-rem")))
    (emit-trailer (full-rem)
      (call-support-function 'sys.int::generic-rem 2)
      (emit `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r9 divisor t)
    (load-in-reg :r8 number t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-rem)
          `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-rem)
          ;; Bail out to the full REM on /0.
          `(sys.lap-x86:test64 :r9 :r9)
          `(sys.lap-x86:jz ,full-rem)
          ;; Don't check for REM -1, don't care about the quotient.
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:cqo)
          `(sys.lap-x86:idiv64 :r9)
          ;; :rdx holds the remainder as a fixnum.
          `(sys.lap-x86:mov64 :r8 :rdx)
          resume)
    (setf *r8-value* (list (gensym)))))

;; FIXME: default divisor to 1
(defbuiltin sys.int::%truncate (number divisor) ()
  (let ((full-truncate (gensym "full-truncate"))
        (resume (gensym "resume-truncate")))
    (emit-trailer (full-truncate)
      (call-support-function 'sys.int::generic-truncate 2
                             (not (member *for-value* '(:multiple :tail))))
      (emit `(sys.lap-x86:jmp ,resume)))
    (load-in-reg :r9 divisor t)
    (load-in-reg :r8 number t)
    (smash-r8)
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-truncate)
          `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,full-truncate)
          ;; Bail out to the full truncate when /0 or /-1.
          `(sys.lap-x86:test64 :r9 :r9)
          `(sys.lap-x86:jz ,full-truncate)
          `(sys.lap-x86:cmp64 :r9 ,(- (ash 1 sys.int::+n-fixnum-bits+)))
          `(sys.lap-x86:je ,full-truncate)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:cqo)
          `(sys.lap-x86:idiv64 :r9)
          ;; :rax holds the dividend as a integer.
          ;; :rdx holds the remainder as a fixnum.
          `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
          `(sys.lap-x86:mov64 :r8 :rax))
    (prog1 (cond ((member *for-value* '(:multiple :tail))
                  (emit `(sys.lap-x86:mov64 :r9 :rdx))
                  (load-constant :rcx 2)
                  :multiple)
                 (t (setf *r8-value* (list (gensym)))))
      (emit resume))))

(defbuiltin ash (integer count) ()
  (cond ((constant-type-p count 'fixnum)
         (setf count (second count))
         (load-in-reg :r8 integer t)
         (let ((not-fixnum (gensym "ash-not-fixnum"))
               (resume (gensym "ash-resume")))
           (emit-trailer (not-fixnum)
             (load-constant :r9 count)
             (call-support-function 'sys.int::%ash 2)
             (load-constant :r13 'sys.int::%ash)
             (emit `(sys.lap-x86:jmp ,resume)))
           (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                 `(sys.lap-x86:jnz ,not-fixnum))
           (cond ((minusp count)
                  ;; Right shift.
                  (setf count (- count))
                  (smash-r8)
                  (cond ((>= count (- 64 sys.int::+n-fixnum-bits+))
                         ;; All bits shifted out.
                         (emit `(sys.lap-x86:cqo)
                               `(sys.lap-x86:and64 :rdx ,(- (ash 1 sys.int::+n-fixnum-bits+)))
                               `(sys.lap-x86:mov64 :r8 :rdx)))
                        (t (emit `(sys.lap-x86:mov64 :rax :r8)
                                 `(sys.lap-x86:sar64 :rax ,count)
                                 `(sys.lap-x86:and64 :rax ,(- (ash 1 sys.int::+n-fixnum-bits+)))
                                 `(sys.lap-x86:mov64 :r8 :rax))))
                  (emit resume)
                  (setf *r8-value* (list (gensym))))
                 ((plusp count)
                  ;; Left shift.
                  ;; Perform the shift one bit at a time so that overflow can be checked for.
                  (let ((ovfl (gensym))
                        (loop-head (gensym)))
                    (emit-trailer (ovfl)
                      ;; Shift count in R9, overflowed value in R8, carry bit set to last
                      ;; bit shifted out.
                      ;; Undo the last shift, then call into the helper function.
                      (emit `(sys.lap-x86:rcr64 :r8 1))
                      (call-support-function 'sys.int::%ash 2)
                      (emit `(sys.lap-x86:jmp ,resume)))
                    (load-constant :r9 count)
                    (smash-r8)
                    (emit loop-head)
                    (emit `(sys.lap-x86:shl64 :r8 1)
                          `(sys.lap-x86:jo ,ovfl)
                          `(sys.lap-x86:sub64 :r9 ,(fixnum-to-raw 1))
                          `(sys.lap-x86:jnz ,loop-head))
                    (emit resume)
                    (setf *r8-value* (list (gensym)))))
                 ((zerop count)
                  ;; Type check only.
                  (emit resume)
                  integer))))
        (t (let ((done-label (gensym))
                 (shift-left (gensym))
                 (shift-right (gensym))
                 (sign-extend (gensym))
                 (ovfl (gensym))
                 (full (gensym))
                 (really-done (gensym))
                 (count-save (allocate-control-stack-slots 1)))
             (emit-trailer (ovfl)
               (emit
                ;; Stash the count.
                `(sys.lap-x86:mov64 ,(control-stack-slot-ea count-save) :rcx)
                ;; Recover carry.
                `(sys.lap-x86:rcr64 :rax 1)
                ;; Drop the remaining fixnum tag bits.
                ;(when (> sys.int::+n-fixnum-bits+ 1)
                ;  (emit `(sys.lap-x86:sar64 :rax ,(1- sys.int::+n-fixnum-bits+))))
                ;; Turn it into a bignum.
                `(sys.lap-x86:mov64 :r13 (:function sys.int::%%make-bignum-64-rax))
                `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
                ;; Fall into the bignum helper.
                `(sys.lap-x86:mov64 :rcx ,(control-stack-slot-ea count-save))
                `(sys.lap-x86:lea64 :r9 ((:rcx ,(ash 1 sys.int::+n-fixnum-bits+)) ,(fixnum-to-raw -1))))
               (call-support-function 'sys.int::%ash 2)
               (emit
                `(sys.lap-x86:jmp ,really-done)))
             (emit-trailer (full)
               (call-support-function 'sys.int::%ash 2)
               (emit
                `(sys.lap-x86:jmp ,really-done)))
             (load-in-reg :r9 count t)
             (emit `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full))
             (fixnum-check :r9)
             (load-in-reg :r8 integer t)
             (smash-r8)
             (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,full))
             (fixnum-check :r8)
             (emit `(sys.lap-x86:mov64 :rcx :r9)
                   `(sys.lap-x86:mov64 :rax :r8)
                   `(sys.lap-x86:cmp64 :rcx 0)
                   `(sys.lap-x86:jz ,done-label)
                   `(sys.lap-x86:jl ,shift-right)
                   ;; Left shift.
                   ;; Perform the shift one bit at a time so that overflow can be checked for.
                   `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
                   shift-left
                   `(sys.lap-x86:shl64 :rax 1)
                   `(sys.lap-x86:jo ,ovfl)
                   `(sys.lap-x86:sub64 :rcx 1)
                   `(sys.lap-x86:jnz ,shift-left)
                   `(sys.lap-x86:jmp ,done-label)
                   ;; x86 masks the shift count to 6 bits, test if all the bits were shifted out.
                   shift-right
                   `(sys.lap-x86:cmp64 :rcx ,(fixnum-to-raw -64))
                   `(sys.lap-x86:jle ,sign-extend)
                   `(sys.lap-x86:sar64 :rcx ,sys.int::+n-fixnum-bits+)
                   `(sys.lap-x86:neg64 :rcx)
                   `(sys.lap-x86:sar64 :rax :cl)
                   `(sys.lap-x86:and64 :rax ,(- (ash 1 sys.int::+n-fixnum-bits+)))
                   `(sys.lap-x86:jmp ,done-label)
                   sign-extend
                   `(sys.lap-x86:cqo)
                   `(sys.lap-x86:and64 :rdx ,(- (ash 1 sys.int::+n-fixnum-bits+)))
                   `(sys.lap-x86:mov64 :rax :rdx)
                   done-label
                   `(sys.lap-x86:mov64 :r8 :rax)
                   really-done)
             (setf *r8-value* (list (gensym)))))))

(defmacro define-conditional-builtin (name generic-name conditional)
  `(defbuiltin ,name (x y) ()
     (let ((generic (gensym))
           (resume (gensym)))
       (emit-trailer (generic)
         (call-support-function ',generic-name 2)
         (emit `(sys.lap-x86:jmp ,resume)))
       (load-in-reg :r9 y t)
       (load-in-reg :r8 x t)
       (smash-r8)
       (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
             `(sys.lap-x86:jnz ,generic)
             `(sys.lap-x86:test64 :r9 ,sys.int::+fixnum-tag-mask+)
             `(sys.lap-x86:jnz ,generic)
             `(sys.lap-x86:cmp64 :r8 :r9)
             `(sys.lap-x86:mov64 :r8 nil)
             `(sys.lap-x86:mov64 :r9 t)
             `(,',(predicate-instruction-cmov-instruction
                   (predicate-info conditional)) :r8 :r9)
             resume)
       (setf *r8-value* (list (gensym))))))

(define-conditional-builtin sys.int::binary-< sys.int::generic-< :l)
(define-conditional-builtin sys.int::binary->= sys.int::generic->= :ge)
(define-conditional-builtin sys.int::binary-> sys.int::generic-> :g)
(define-conditional-builtin sys.int::binary-<= sys.int::generic-<= :le)
(define-conditional-builtin sys.int::binary-= sys.int::generic-= :e)

(define-array-like-predicate symbolp sys.int::+object-tag-symbol+)
(define-array-like-reader symbol-name symbol sys.int::+object-tag-symbol+ +symbol-name+)
(define-array-like-accessor symbol-package symbol sys.int::+object-tag-symbol+ +symbol-package+)

(defbuiltin symbol-value (symbol) ()
  (let ((unbound-error-label (gensym))
        (no-tls-slot (gensym))
        (test-bound (gensym)))
    (emit-trailer (unbound-error-label)
      (emit `(sys.lap-x86:mov64 :r8 :r9))
      (call-support-function 'sys.int::raise-unbound-error 1)
      (emit `(sys.lap-x86:ud2)))
    (load-in-reg :r9 symbol t)
    (emit-object-type-check :r9 sys.int::+object-tag-symbol+ 'symbol symbol)
    (smash-r8)
    (emit ;; Extract the TLS offset.
          `(sys.lap-x86:mov64 :rax ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:shr64 :rax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Read from the TLS slot.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :r8 ((:rax 8) ,+tls-base-offset+))
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:cmp64 :r8 :unbound-tls-slot)
          `(sys.lap-x86:jne ,test-bound)
          no-tls-slot
	  `(sys.lap-x86:mov64 :r8 ,(object-ea :r9 :slot +symbol-value+))
          test-bound
	  `(sys.lap-x86:cmp64 :r8 :unbound-value)
	  `(sys.lap-x86:je ,unbound-error-label))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf symbol-value) (value symbol) ()
  (let ((no-tls-slot (gensym))
        (out (gensym)))
    (load-in-reg :r9 symbol t)
    (load-in-reg :r8 value t)
    (emit-object-type-check :r9 sys.int::+object-tag-symbol+ 'symbol symbol)
    (emit ;; Extract the TLS offset.
          `(sys.lap-x86:mov64 :rax ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:shr64 :rax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 ((:rax 8) ,+tls-base-offset+) :unbound-tls-slot)
          `(sys.lap-x86:je ,no-tls-slot)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 ((:rax 8) ,+tls-base-offset+) :r8)
          `(sys.lap-x86:jmp ,out)
          no-tls-slot
          `(sys.lap-x86:mov64 ,(object-ea :r9 :slot +symbol-value+) :r8)
          out)
    *r8-value*))

(defbuiltin sys.int::symbol-global-value (symbol) ()
  (let ((unbound-error-label (gensym)))
    (emit-trailer (unbound-error-label)
      (emit `(sys.lap-x86:mov64 :r8 :r9))
      (call-support-function 'sys.int::raise-unbound-error 1)
      (emit `(sys.lap-x86:ud2)))
    (load-in-reg :r9 symbol t)
    (emit-object-type-check :r9 sys.int::+object-tag-symbol+ 'symbol symbol)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r9 :slot +symbol-value+))
	  `(sys.lap-x86:cmp64 :r8 :unbound-value)
	  `(sys.lap-x86:je ,unbound-error-label))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::symbol-global-value) (value symbol) ()
  (load-in-reg :r9 symbol t)
  (load-in-reg :r8 value t)
  (emit-object-type-check :r9 sys.int::+object-tag-symbol+ 'symbol symbol)
  (emit `(sys.lap-x86:mov64 ,(object-ea :r9 :slot +symbol-value+) :r8))
  *r8-value*)

(defbuiltin sys.int::%cas-symbol-global-value (symbol old new) ()
  (load-in-reg :r9 symbol t)
  (load-in-reg :r11 new t)
  (load-in-reg :r8 old t)
  (smash-r8)
  (emit-object-type-check :r9 sys.int::+object-tag-symbol+ 'symbol symbol)
  ;; CAS.
  (emit `(sys.lap-x86:mov64 :rax :r8))
  (emit-gc-info :extra-registers :rax)
  (emit `(sys.lap-x86:lock)
        `(sys.lap-x86:cmpxchg ,(object-ea :r9 :slot +symbol-value+) :r11))
  (cond ((member *for-value* '(:multiple :tail))
         ;; Return success and the old value.
         (emit `(sys.lap-x86:mov64 :r9 :rax))
         (emit-gc-info)
         (emit `(sys.lap-x86:mov64 :r8 nil)
               `(sys.lap-x86:cmov64z :r8 (:constant t)))
         (load-constant :rcx 2)
         :multiple)
        (t ;; Just return the success state.
         (emit-gc-info)
         (predicate-result :z))))

(define-array-like-accessor sys.int::symbol-fref symbol sys.int::+object-tag-symbol+ +symbol-function+)

;; TODO type checking? ensure value is a plist?
(define-array-like-accessor symbol-plist symbol sys.int::+object-tag-symbol+ +symbol-plist+)

;; TODO: type checking, value should be a fixnum.
#+(or)(define-array-like-accessor sys.int::%symbol-flags symbol sys.int::+object-tag-symbol+ :symbol-flags)

;;; TODO: should just test the tag bits.
(defbuiltin boundp (symbol) ()
  (let ((no-tls-slot (gensym))
        (out (gensym)))
    (load-in-reg :r8 symbol t)
    (emit-object-type-check :r8 sys.int::+object-tag-symbol+ 'symbol symbol)
    (smash-r8)
    (emit ;; Extract the TLS offset.
          `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:shr64 :rax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Read from the TLS slot.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :r9 ((:rax 8) ,+tls-base-offset+))
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:cmp64 :r9 :unbound-tls-slot)
          `(sys.lap-x86:je ,no-tls-slot)
	  `(sys.lap-x86:cmp64 :r9 :unbound-value)
          `(sys.lap-x86:jmp ,out)
          no-tls-slot
	  `(sys.lap-x86:cmp64 ,(object-ea :r8 :slot +symbol-value+)
                              :unbound-value)
          out)
    (predicate-result :ne)))

(defbuiltin makunbound (symbol) ()
  (let ((no-tls-slot (gensym))
        (out (gensym)))
    (load-in-reg :r8 symbol t)
    (emit-object-type-check :r8 sys.int::+object-tag-symbol+ 'symbol symbol)
    (emit ;; Extract the TLS offset.
          `(sys.lap-x86:mov32 :eax ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jz ,no-tls-slot)
          ;; Check if the TLS slot holds a value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:cmp64 ((:rax 8) ,+tls-base-offset+) :unbound-tls-slot)
          `(sys.lap-x86:je ,no-tls-slot)
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 ((:rax 8) ,+tls-base-offset+) :unbound-value)
          `(sys.lap-x86:jmp ,out)
          no-tls-slot
	  `(sys.lap-x86:mov64 ,(object-ea :r8 :slot +symbol-value+) :unbound-value)
          out)
    *r8-value*))

(define-tag-type-predicate consp sys.int::+tag-cons+)

(defbuiltin car (list) ()
  (let ((type-error-label (gensym))
        (out-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'list))
    (load-in-reg :r8 list t)
    (smash-r8)
    (emit `(sys.lap-x86:cmp64 :r8 nil)
          `(sys.lap-x86:je ,out-label)
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :r8 (:car :r8))
          out-label)
    (setf *r8-value* (list (gensym)))))

(defbuiltin cdr (list) ()
  (let ((type-error-label (gensym))
        (out-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'list))
    (load-in-reg :r8 list t)
    (smash-r8)
    (emit `(sys.lap-x86:cmp64 :r8 nil)
          `(sys.lap-x86:je ,out-label)
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-cons+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :r8 (:cdr :r8))
          out-label)
    (setf *r8-value* (list (gensym)))))

(define-writer (setf car) cons sys.int::+tag-cons+ :car)
(define-writer (setf cdr) cons sys.int::+tag-cons+ :cdr)

(defbuiltin null (object) ()
  (load-in-reg :r8 object t)
  (emit `(sys.lap-x86:cmp64 :r8 nil))
  (predicate-result :e))

(defbuiltin not (object) ()
  (load-in-reg :r8 object t)
  (emit `(sys.lap-x86:cmp64 :r8 nil))
  (predicate-result :e))

(defbuiltin eq (x y) ()
  ;; Ensure constants are on the right-hand side.
  (when (quoted-constant-p x)
    (rotatef x y))
  (cond ((quoted-constant-p y)
         (let ((constant (second y)))
           (load-in-reg :r8 x t)
           ;; Should characters and single-floats be loaded into a register
           ;; for comparison or should they be compared through the constant
           ;; pool? Currently they go through the constant pool...
           (cond
             ((small-fixnum-p constant)
              (emit `(sys.lap-x86:cmp64 :r8 ,(fixnum-to-raw constant))))
             (t (emit `(sys.lap-x86:cmp64 :r8 (:constant ,constant)))))
           (predicate-result :e)))
        (t (load-in-reg :r9 y t)
           (load-in-reg :r8 x t)
           (emit `(sys.lap-x86:cmp64 :r8 :r9))
           (predicate-result :e))))

(defbuiltin eql (x y) ()
  ;; Ensure constants are on the right-hand side.
  (when (quoted-constant-p x)
    (rotatef x y))
  (cond ((quoted-constant-p y)
         (let ((constant (second y)))
           (load-in-reg :r8 x t)
           ;; Should characters and single-floats be loaded into a register
           ;; for comparison or should they be compared through the constant
           ;; pool? Currently they go through the constant pool...
           (cond
             ((small-fixnum-p constant)
              (emit `(sys.lap-x86:cmp64 :r8 ,(fixnum-to-raw constant))))
             (t (emit `(sys.lap-x86:cmp64 :r8 (:constant ,constant)))))
           (predicate-result :e)))
        (t (load-in-reg :r9 y t)
           (load-in-reg :r8 x t)
           ;; FIXME: Broken.
           (emit `(sys.lap-x86:cmp64 :r8 :r9))
           (predicate-result :e))))

(defun emit-port-access (instruction port port-reg)
  (cond ((and (quoted-constant-p port)
              (typep (second port) '(unsigned-byte 8)))
         ;; Small port number, fits directly in the instruction.
         (setf *load-list* (delete port *load-list*))
         (emit (list instruction (second port))))
        ((and (quoted-constant-p port)
              (typep (second port) '(unsigned-byte 8)))
         ;; Large port number, needs to be loaded into dx.
         (setf *load-list* (delete port *load-list*))
         (emit `(sys.lap-x86:mov16 :dx ,(second port))
               (list instruction :dx)))
        (t ;; Unknown port.
         (let ((type-error-label (gensym "port-type-error")))
           (emit-trailer (type-error-label)
             (raise-type-error port-reg '(unsigned-byte 16)))
           (load-in-reg port-reg port t)
           (emit `(sys.lap-x86:test64 ,port-reg ,sys.int::+fixnum-tag-mask+)
                 `(sys.lap-x86:cmp64 ,port-reg ,(fixnum-to-raw #x10000))
                 `(sys.lap-x86:jae ,type-error-label)
                 `(sys.lap-x86:mov64 :rdx ,port-reg)
                 ;; Convert to a raw integer.
                 `(sys.lap-x86:sar32 :edx ,sys.int::+n-fixnum-bits+)
                 (list instruction :dx))))))

(defbuiltin system:io-port/8 (port) ()
  (smash-r8)
  (emit `(sys.lap-x86:xor32 :eax :eax))
  (emit-port-access 'sys.lap-x86:in8 port :r8)
  (emit `(sys.lap-x86:shl32 :eax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:mov32 :r8d :eax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf system:io-port/8) (value port) ()
  (load-in-r8 value t)
  (let ((value-type-error-label (gensym)))
    (emit-trailer (value-type-error-label)
      (raise-type-error :r8 '(unsigned-byte 8)))
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,value-type-error-label)
          `(sys.lap-x86:cmp64 :r8 ,(fixnum-to-raw #x100))
          `(sys.lap-x86:jae ,value-type-error-label)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:sar32 :eax ,sys.int::+n-fixnum-bits+))
    (emit-port-access 'sys.lap-x86:out8 port :r9)
    value))

(defbuiltin system:io-port/16 (port) ()
  (smash-r8)
  (emit `(sys.lap-x86:xor32 :eax :eax))
  (emit-port-access 'sys.lap-x86:in16 port :r8)
  (emit `(sys.lap-x86:shl32 :eax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:mov32 :r8d :eax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf system:io-port/16) (value port) ()
  (load-in-r8 value t)
  (let ((value-type-error-label (gensym)))
    (emit-trailer (value-type-error-label)
      (raise-type-error :r8 '(unsigned-byte 8)))
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,value-type-error-label)
          `(sys.lap-x86:cmp64 :r8 ,(fixnum-to-raw #x10000))
          `(sys.lap-x86:jae ,value-type-error-label)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:sar32 :eax ,sys.int::+n-fixnum-bits+))
    (emit-port-access 'sys.lap-x86:out16 port :r9)
    value))

(defbuiltin system:io-port/32 (port) ()
  (smash-r8)
  (emit `(sys.lap-x86:xor32 :eax :eax))
  (emit-port-access 'sys.lap-x86:in32 port :r8)
  (emit `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:mov64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf system:io-port/32) (value port) ()
  (load-in-r8 value t)
  (let ((value-type-error-label (gensym)))
    (emit-trailer (value-type-error-label)
      (raise-type-error :r8 '(unsigned-byte 8)))
    (emit `(sys.lap-x86:test64 :r8 ,sys.int::+fixnum-tag-mask+)
          `(sys.lap-x86:jnz ,value-type-error-label)
          `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
          `(sys.lap-x86:mov64 :rdx :rax)
          `(sys.lap-x86:sar64 :rdx 32)
          `(sys.lap-x86:jnz ,value-type-error-label))
    (emit-port-access 'sys.lap-x86:out32 port :r9)
    value))

(defbuiltin simple-vector-p (object) ()
  (let ((out (gensym)))
    (load-in-r8 object t)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,out)
          `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:test8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                        sys.int::+array-type-shift+))
          ;; Subtle. OUT can be reached through either the tag check
          ;; or through the array type check. Both checks clear ZF when
          ;; they fail.
          out)
    (predicate-result :z)))

(defbuiltin svref (simple-vector index) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'simple-vector))
    (emit-trailer (bounds-error-label)
      (emit `(sys.lap-x86:mov64 :r13 (:function sys.int::raise-bounds-error))
            `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r8 simple-vector t)
    (smash-r8)
    (load-in-reg :r9 index t)
    (fixnum-check :r9)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error-label)
          ;; Load header word.
          `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :slot -1))
          ;; Check array type.
          `(sys.lap-x86:test8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                        sys.int::+array-type-shift+))
          `(sys.lap-x86:jnz ,type-error-label)
          ;; Check bounds.
          `(sys.lap-x86:mov64 :rcx :r9)
          `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
          `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Load!
          `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :index '(:rcx 8))))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%svref (simple-vector index) ()
  "Fast SVREF. No type check or bounds check."
  (load-in-r8 simple-vector t)
  (smash-r8)
  (cond ((quoted-constant-p index)
         (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot (second index)))))
        (t (load-in-reg :r9 index t)
           (emit `(sys.lap-x86:mov64 :rax :r9)
                 `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+))
           (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :index '(:rax 8))))))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf svref) (value simple-vector index) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'simple-vector))
    (emit-trailer (bounds-error-label)
      (emit `(sys.lap-x86:mov64 :r8 :r9)
            `(sys.lap-x86:mov64 :r9 :r10)
            `(sys.lap-x86:mov64 :r13 (:function sys.int::raise-bounds-error))
            `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r8 value t)
    (load-in-reg :r9 simple-vector t)
    (load-in-reg :r10 index t)
    (fixnum-check :r10)
    (emit `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error-label)
          ;; Load header word.
          `(sys.lap-x86:mov64 :rax ,(object-ea :r9 :slot -1))
          ;; Check array type.
          `(sys.lap-x86:test8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                        sys.int::+array-type-shift+))
          `(sys.lap-x86:jnz ,type-error-label)
          ;; Check bounds.
          `(sys.lap-x86:mov64 :rcx :r10)
          `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
          `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Store!
          `(sys.lap-x86:mov64 ,(object-ea :r9 :index '(:rcx 8)) :r8))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::%svref) (value simple-vector index) ()
  "Fast SVREF. No type check or bounds check."
  (load-in-reg :r8 value t)
  (load-in-reg :r9 simple-vector t)
  (cond ((quoted-constant-p index)
         (emit `(sys.lap-x86:mov64 ,(object-ea :r9 :slot (second index)) :r8)))
        (t (load-in-reg :r10 index t)
           (emit `(sys.lap-x86:mov64 :rax :r10)
                 `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+))
           (emit `(sys.lap-x86:mov64 ,(object-ea :r9 :index '(:rax 8)) :r8))))
  (setf *r8-value* (list (gensym))))

(define-tag-type-predicate characterp sys.int::+tag-character+)

(defbuiltin system.internals::read-frame-pointer () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :rax :cfp)
        `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:mov64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(define-array-like-predicate system.internals::structure-object-p
    sys.int::+object-tag-structure-object+)

(defbuiltin system.internals::%struct-slot (object slot) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'structure-object))
    (emit-trailer (bounds-error-label)
      (emit `(sys.lap-x86:mov64 :r13 (:function sys.int::raise-bounds-error))
            `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r9 slot t)
    (fixnum-check :r9)
    (load-in-reg :r8 object t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+object-tag-structure-object+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:jne ,type-error-label)
          ;; Convert size and slot number to integers.
          `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
          `(sys.lap-x86:mov64 :rcx :r9)
          `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
          ;; Check bounds.
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Load.
          `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :index '(:rcx 8))))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf system.internals::%struct-slot) (value object slot) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'structure-object))
    (emit-trailer (bounds-error-label)
      (emit `(sys.lap-x86:mov64 :r8 :r9)
            `(sys.lap-x86:mov64 :r9 :r10)
            `(sys.lap-x86:mov64 :r13 (:function sys.int::raise-bounds-error))
            `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r10 slot t)
    (fixnum-check :r10)
    (load-in-reg :r9 object t)
    (load-in-reg :r8 value t)
    (emit `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :rax ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+object-tag-structure-object+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:jne ,type-error-label)
          ;; Convert size and slot number to integers.
          `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
          `(sys.lap-x86:mov64 :rcx :r10)
          `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
          ;; Check bounds.
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Store.
          `(sys.lap-x86:mov64 ,(object-ea :r9 :index '(:rcx 8)) :r8))
    *r8-value*))

(defbuiltin sys.int::%cas-struct-slot (object slot old new) ()
  (let ((type-error-label (gensym))
        (bounds-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r9 'structure-object))
    (emit-trailer (bounds-error-label)
      (emit `(sys.lap-x86:mov64 :r8 :r9)
            `(sys.lap-x86:mov64 :r9 :r10)
            `(sys.lap-x86:mov64 :r13 (:function sys.int::raise-bounds-error))
            `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw 2))
            `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))
            `(sys.lap-x86:ud2)))
    (load-in-reg :r10 slot t)
    (fixnum-check :r10)
    (load-in-reg :r9 object t)
    (load-in-reg :r11 new t)
    (load-in-reg :r8 old t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :rax ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+object-tag-structure-object+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:jne ,type-error-label)
          ;; Convert size and slot number to integers.
          `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
          `(sys.lap-x86:mov64 :rcx :r10)
          `(sys.lap-x86:shr64 :rcx ,sys.int::+n-fixnum-bits+)
          ;; Check bounds.
          `(sys.lap-x86:cmp64 :rcx :rax)
          `(sys.lap-x86:jae ,bounds-error-label)
          ;; Load value.
          `(sys.lap-x86:mov64 :rax :r8)
          (emit-gc-info :extra-registers :rax)
          `(sys.lap-x86:lock)
          `(sys.lap-x86:cmpxchg ,(object-ea :r9 :index '(:rcx 8)) :r11))
    (cond ((member *for-value* '(:multiple :tail))
           ;; Return success and the old value.
           (emit `(sys.lap-x86:mov64 :r9 :rax))
           (emit-gc-info)
           (emit `(sys.lap-x86:mov64 :r8 nil)
                 `(sys.lap-x86:cmov64z :r8 (:constant t)))
           (load-constant :rcx 2)
           :multiple)
          (t ;; Just return the success state.
           (emit-gc-info)
           (predicate-result :z)))))

(defbuiltin char-code (char) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 'character))
    (load-in-r8 char t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-character+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Mask away the non-code bits.
	  `(sys.lap-x86:and32 :r8d #x01fffff0)
	  ;; Shift to fixnum.
	  `(sys.lap-x86:shr32 :r8d ,(- 4 sys.int::+n-fixnum-bits+)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::char-bits (character) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 'character))
    (load-in-r8 character t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-character+)
          `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:and32 :r8d #x1e000000)
          `(sys.lap-x86:shr32 :r8d ,(- 25 sys.int::+n-fixnum-bits+)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin char-int (char) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
		  (raise-type-error :r8 'character))
    (load-in-r8 char t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-character+)
	  `(sys.lap-x86:jne ,type-error-label)
	  ;; Mask away the tag bits.
	  `(sys.lap-x86:and32 :r8d -16)
	  ;; Shift to fixnum.
	  `(sys.lap-x86:shr32 :r8d ,(- 4 sys.int::+n-fixnum-bits+)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin system:fixnump (object) ()
  (load-in-reg :r8 object t)
  (emit `(sys.lap-x86:test8 :r8l ,sys.int::+fixnum-tag-mask+))
  (predicate-result :z))

(defbuiltin sys.int::%%assemble-value (address tag) ()
  (load-in-reg :rax tag t)
  (load-in-reg :r8 address t)
  (smash-r8)
  (emit `(sys.lap-x86:shr32 :eax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:shr64 :r8 ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:or64 :r8 :rax))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%pointer-field (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  (emit `(sys.lap-x86:and64 :r8 -16)
        `(sys.lap-x86:shr64 :r8 ,(- 4 sys.int::+n-fixnum-bits+)))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%tag-field (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  (emit `(sys.lap-x86:shl64 :r8 ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:and64 :r8 ,(ash (1- (ash 1 4)) sys.int::+n-fixnum-bits+)))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::lisp-object-address (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  ;; Convert to fixnum.
  (emit `(sys.lap-x86:shl64 :r8 ,sys.int::+n-fixnum-bits+))
  (setf *r8-value* (list (gensym))))

(define-array-like-predicate sys.int::std-instance-p sys.int::+object-tag-std-instance+)
(define-array-like-accessor sys.int::std-instance-class
    sys.int::std-instance sys.int::+object-tag-std-instance+
    0)
(define-array-like-accessor sys.int::std-instance-slots
    sys.int::std-instance sys.int::+object-tag-std-instance+
    1)

(defbuiltin functionp (object) ()
  (let ((out (gensym)))
    (load-in-reg :r9 object t)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :r8 nil)
          ;; Check tag.
          `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,out)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-function-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-function-object-tag+
                                          sys.int::+first-function-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmov64be :r8 (:constant t))
          out)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%stihlt () ()
  (emit `(sys.lap-x86:sti)
        `(sys.lap-x86:hlt))
  ''nil)

(defbuiltin sys.int::%sti () ()
  (emit `(sys.lap-x86:sti))
  ''nil)

(defbuiltin sys.int::%cli () ()
  (emit `(sys.lap-x86:cli))
  ''nil)

(defbuiltin sys.int::%hlt () ()
  (emit `(sys.lap-x86:hlt))
  ''nil)

(defbuiltin sys.int::%interrupt-state () ()
  (emit `(sys.lap-x86:pushf)
        `(sys.lap-x86:pop :rax)
        `(sys.lap-x86:test32 :eax #x200))
  (predicate-result :nz))

;; These functions save & restore the entire state of the flags register.
(defbuiltin sys.int::%save-irq-state () ()
  (smash-r8)
  (emit `(sys.lap-x86:pushf)
        `(sys.lap-x86:shl64 (:rsp) ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:pop :r8))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%restore-irq-state (saved-state) ()
  (load-in-r8 saved-state t)
  (emit `(sys.lap-x86:push :r8)
        `(sys.lap-x86:shr64 (:rsp) ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:popf))
  saved-state)

(macrolet ((def (name reg)
             `(progn
                (defbuiltin ,name () ()
                  (smash-r8)
                  (emit `(sys.lap-x86:movcr :rax ,',reg)
                        `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
                        `(sys.lap-x86:mov64 :r8 :rax))
                  (setf *r8-value* (list (gensym))))
                (defbuiltin (setf ,name) (value) ()
                  (load-in-r8 value t)
                  (fixnum-check :r8)
                  (emit `(sys.lap-x86:mov64 :rax :r8)
                        `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
                        `(sys.lap-x86:movcr ,',reg :rax))
                  value))))
  (def sys.int::%cr0 :cr0)
  (def sys.int::%cr2 :cr2)
  (def sys.int::%cr3 :cr3)
  (def sys.int::%cr4 :cr4))

(macrolet ((def (name reg)
             `(progn
                (defbuiltin ,name () ()
                  (smash-r8)
                  (emit `(sys.lap-x86:movdr :rax ,',reg)
                        `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
                        `(sys.lap-x86:mov64 :r8 :rax))
                  (setf *r8-value* (list (gensym))))
                (defbuiltin (setf ,name) (value) ()
                  (load-in-r8 value t)
                  (fixnum-check :r8)
                  (emit `(sys.lap-x86:mov64 :rax :r8)
                        `(sys.lap-x86:sar64 :rax ,sys.int::+n-fixnum-bits+)
                        `(sys.lap-x86:movdr ,',reg :rax))
                  value))))
  (def sys.int::%dr0 :dr0)
  (def sys.int::%dr1 :dr1)
  (def sys.int::%dr2 :dr2)
  (def sys.int::%dr3 :dr3)
  (def sys.int::%dr6 :dr6)
  (def sys.int::%dr7 :dr7))

(define-array-like-predicate sys.int::bignump sys.int::+object-tag-bignum+)
(define-tag-type-predicate floatp sys.int::+tag-single-float+)

(defbuiltin sys.int::%array-like-length (thing) ()
  (let ((type-error-label (gensym)))
    (emit-trailer (type-error-label)
      (raise-type-error :r8 '%array-like))
    (load-in-r8 thing t)
    (smash-r8)
    (emit `(sys.lap-x86:mov8 :al :r8l)
	  `(sys.lap-x86:and8 :al #b1111)
	  `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
	  `(sys.lap-x86:jne ,type-error-label)
          `(sys.lap-x86:mov64 :rax ,(object-ea :r8 :slot -1))
	  ;; Convert length to fixnum.
	  `(sys.lap-x86:shr64 :rax ,sys.int::+array-length-shift+)
	  `(sys.lap-x86:shl64 :rax ,sys.int::+n-fixnum-bits+)
	  `(sys.lap-x86:mov64 :r8 :rax))
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%object-tag (thing) ()
  (load-in-r8 thing t)
  (smash-r8)
  (emit `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
        `(sys.lap-x86:and32 :eax #xFF)
        `(sys.lap-x86:shr32 :eax ,sys.int::+array-type-shift+)
        `(sys.lap-x86:shl32 :eax ,sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:mov32 :r8d :eax))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%%special-stack-pointer () ()
  (smash-r8)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 :r8 (,+binding-stack-gs-offset+)))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::%%special-stack-pointer) (value) ()
  (load-in-r8 value t)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 (,+binding-stack-gs-offset+) :r8))
  value)

(defun get-block/tagbody-info-binding-stack-pointer (info)
  ;; Read the saved binding stack pointer from a block/tagbody-info.
  (load-in-r8 info t)
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :r8 (:r8 8)))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%%block-info-binding-stack-pointer (block-info) ()
  (get-block/tagbody-info-binding-stack-pointer block-info))

(defbuiltin sys.int::%%tagbody-info-binding-stack-pointer (tagbody-info) ()
  (get-block/tagbody-info-binding-stack-pointer tagbody-info))

(defun push-special-stack (object value &optional (tmp :rbx) (tmp2 :r12))
  (let ((slots (allocate-control-stack-slots 4 t)))
    ;; Flush slots.
    (emit `(sys.lap-x86:mov64 (:stack ,(+ slots 3)) ,(ash 3 sys.int::+array-length-shift+))
          `(sys.lap-x86:mov64 (:stack ,(+ slots 2)) nil)
          `(sys.lap-x86:mov64 (:stack ,(+ slots 1)) nil)
          `(sys.lap-x86:mov64 (:stack ,(+ slots 0)) nil))
    ;; Generate pointer.
    (emit `(sys.lap-x86:lea64 ,tmp (:rbp ,(+ (control-stack-frame-offset (+ slots 3))
                                             sys.int::+tag-object+))))
    ;; Store bits.
    (emit `(sys.lap-x86:mov64 (:stack ,(+ slots 1)) ,object)
          `(sys.lap-x86:mov64 (:stack ,(+ slots 0)) ,value))
    ;; Store link.
    (emit `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 ,tmp2 (,+binding-stack-gs-offset+))
          `(sys.lap-x86:mov64 (:stack ,(+ slots 2)) ,tmp2))
    ;; Push.
    (emit `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 (,+binding-stack-gs-offset+) ,tmp))))

;;; TODO: Check for constants here.
(defbuiltin sys.int::%%bind (symbol value) (t nil)
  ;; Don't kill here, going to reload & kill later in the function.
  (load-in-reg :r9 symbol)
  (smash-r8)
  (let ((has-tls-slot (gensym)))
    ;; Ensure there is a TLS slot.
    (emit `(sys.lap-x86:mov32 :eax ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:shr32 :eax ,+tls-offset-shift+)
          `(sys.lap-x86:and32 :eax #xFFFF)
          `(sys.lap-x86:jnz ,has-tls-slot))
    ;; Nope, allocate a new one.
    (emit `(sys.lap-x86:mov64 :r8 :r9))
    (call-support-function 'sys.int::%allocate-tls-slot 1)
    (load-in-reg :r9 symbol t)
    (emit `(sys.lap-x86:mov64 :rax :r8)
          `(sys.lap-x86:shr32 :eax ,sys.int::+n-fixnum-bits+)
          has-tls-slot
          ;; Save the old value on the binding stack.
          ;; Read the old symbol value.
          `(sys.lap-x86:gs)
          `(sys.lap-x86:mov64 :r10 ((:rax 8) ,+tls-base-offset+)))
    (push-special-stack :r9 :r10))
  ;; Store new value.
  (load-in-r8 value t)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 ((:rax 8) ,+tls-base-offset+) :r8))
  ''nil)

;;; TODO: Check for constants here.
(defbuiltin sys.int::%%push-special-stack (a b) (t nil)
  (load-in-reg :r9 b t)
  (load-in-reg :r8 a t)
  (push-special-stack :r8 :r9)
  ''nil)

(defbuiltin sys.int::%%unbind () (t nil)
  ;; Top entry in the binding stack is a special variable binding.
  ;; It's a symbol and the old value.
  ;; Pop the stack & restore the old value.
  (smash-r8)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 :rbx (,+binding-stack-gs-offset+))
        `(sys.lap-x86:mov64 :r8 ,(object-ea :rbx :slot 1))
        `(sys.lap-x86:mov64 :r9 ,(object-ea :rbx :slot 2))
        `(sys.lap-x86:mov32 :edx ,(object-ea :r8 :slot -1))
        `(sys.lap-x86:shr32 :edx ,+tls-offset-shift+)
        `(sys.lap-x86:and32 :edx #xFFFF)
        `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 ((:rdx 8) ,+tls-base-offset+) :r9)
        `(sys.lap-x86:mov64 :rbx ,(object-ea :rbx :slot 0))
        `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 (,+binding-stack-gs-offset+) :rbx))
  ''nil)

(defbuiltin sys.int::%%disestablish-block-or-tagbody () (t nil)
  ;; Top entry in the binding stack is a block or tagbody entry.
  ;; It's a environment simple-vector & an offset.
  ;; Pop the stack & set env[offset] = NIL.
  (smash-r8)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 :rbx (,+binding-stack-gs-offset+))
        `(sys.lap-x86:mov64 :r8 ,(object-ea :rbx :slot 1))
        `(sys.lap-x86:mov64 :rcx ,(object-ea :rbx :slot 2))
        `(sys.lap-x86:mov64 ,(object-ea :r8 :index `(:rcx ,(/ 8 (ash 1 sys.int::+n-fixnum-bits+)))) nil)
        `(sys.lap-x86:mov64 :rbx ,(object-ea :rbx :slot 0))
        `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 (,+binding-stack-gs-offset+) :rbx))
  ''nil)

(defbuiltin sys.int::%%disestablish-unwind-protect () (t nil)
  ;; Top entry in the binding stack is an unwind-protect entry.
  ;; It's a function and environment object.
  ;; Pop the stack & call the function with the environment object.
  (smash-r8)
  (emit `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 :r8 (,+binding-stack-gs-offset+))
        `(sys.lap-x86:mov64 :r13 ,(object-ea :r8 :slot 1))
        `(sys.lap-x86:mov64 :rbx ,(object-ea :r8 :slot 2))
        `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot 0))
        `(sys.lap-x86:gs)
        `(sys.lap-x86:mov64 (,+binding-stack-gs-offset+) :r8)
        `(sys.lap-x86:xor32 :ecx :ecx)
        `(sys.lap-x86:call ,(object-ea :r13 :slot 0)))
  ''nil)

(defun call-support-function (name n-args &optional (single-value t))
  (declare (ignore single-value))
  (emit `(sys.lap-x86:mov64 :r13 (:function ,name))
        `(sys.lap-x86:mov32 :ecx ,(fixnum-to-raw n-args))
        `(sys.lap-x86:call ,(object-ea :r13 :slot sys.int::+fref-entry-point+))))

(defun emit-type-error (register type)
  (let ((label (gensym "type-error")))
    (emit-trailer (label)
      (raise-type-error register type))
    label))

(defun unpack-ub32-fixnum-into-register (value target scratch)
  (let ((reg64 (sys.lap-x86::convert-width target 64))
        (reg32 (sys.lap-x86::convert-width target 32)))
    (cond ((and (quoted-constant-p value)
                (typep (second value) '(unsigned-byte 32)))
           (emit `(sys.lap-x86:mov32 ,reg32 ,(second value))))
          (t (let ((type-error-label (emit-type-error scratch '(unsigned-byte 32))))
               (load-in-r8 value t)
               (smash-r8)
               (emit `(sys.lap-x86:test64 ,scratch ,sys.int::+fixnum-tag-mask+)
                     `(sys.lap-x86:jnz ,type-error-label)
                     `(sys.lap-x86:mov64 ,reg64 ,scratch)
                     `(sys.lap-x86:sar64 ,reg64 ,(+ 32 sys.int::+n-fixnum-bits+))
                     `(sys.lap-x86:jnz ,type-error-label)
                     `(sys.lap-x86:mov64 ,reg64 ,scratch)
                     `(sys.lap-x86:shr64 ,reg64 ,sys.int::+n-fixnum-bits+)))))))

(defbuiltin sys.int::msr (register) ()
  (smash-r8)
  (unpack-ub32-fixnum-into-register register :rcx :r8)
  (emit `(sys.lap-x86:rdmsr)
        ;; Pack result into one register
        `(sys.lap-x86:shl64 :rdx 32)
        `(sys.lap-x86:or64 :rax :rdx))
  (box-unsigned-byte-64-rax)
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::msr) (value register) ()
  (smash-r8)
  (unpack-ub32-fixnum-into-register register :rcx :r8)
  (cond ((and (quoted-constant-p value)
              (typep (second value) '(or (unsigned-byte 64)
                                         (signed-byte 64))))
         (emit `(sys.lap-x86:mov32 :eax ,(ldb (byte 32 0) (second value)))
               `(sys.lap-x86:mov32 :edx ,(ldb (byte 32 32) (second value)))))
        (t (let ((type-error-label (gensym))
                 (bignum-path (gensym "mr-ub64-bignum"))
                 (len-2-bignum (gensym "mr-ub64-len-2-bignum"))
                 (value-extracted (gensym "mr-ub64-value-extracted")))
             (emit-trailer (bignum-path)
               ;; Check for bignumness.
               (emit `(sys.lap-x86:and8 :dl #b1111)
                     `(sys.lap-x86:cmp8 :dl ,sys.int::+tag-object+)
                     `(sys.lap-x86:jne ,type-error-label)
                     `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot -1))
                     `(sys.lap-x86:and8 :dl ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                                  sys.int::+array-type-shift+))
                     `(sys.lap-x86:cmp8 :dl ,(ash sys.int::+object-tag-bignum+
                                                  sys.int::+array-type-shift+))
                     `(sys.lap-x86:jne ,type-error-label)
                     `(sys.lap-x86:shr64 :rdx ,sys.int::+array-length-shift+)
                     ;; RDX = bignum length.
                     `(sys.lap-x86:cmp64 :rdx 2)
                     `(sys.lap-x86:je ,len-2-bignum)
                     ;; Not length 2, must be length 1.
                     `(sys.lap-x86:cmp64 :rdx 1)
                     `(sys.lap-x86:jne ,type-error-label)
                     ;; And the sign bit must be clear.
                     `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
                     `(sys.lap-x86:shl64 :rdx 1)
                     `(sys.lap-x86:jc ,type-error-label)
                     `(sys.lap-x86:rcr64 :rdx 1)
                     `(sys.lap-x86:jmp ,value-extracted)
                     len-2-bignum
                     ;; Length 2 bignums must have the high word be 0.
                     `(sys.lap-x86:cmp64 ,(object-ea :r8 :slot 1) 0)
                     `(sys.lap-x86:jne ,type-error-label)
                     `(sys.lap-x86:mov64 :rdx ,(object-ea :r8 :slot 0))
                     `(sys.lap-x86:jmp ,value-extracted)
                     type-error-label)
               (raise-type-error :r8 '(or (unsigned-byte 64)
                                          (signed-byte 64))))
             (load-in-r8 value t)
             (emit `(sys.lap-x86:mov64 :rdx :r8)
                   `(sys.lap-x86:test64 :rdx ,sys.int::+fixnum-tag-mask+)
                   `(sys.lap-x86:jnz ,bignum-path)
                   `(sys.lap-x86:sar64 :rdx ,sys.int::+n-fixnum-bits+)
                   value-extracted
                   `(sys.lap-x86:mov64 :rax :rdx)
                   `(sys.lap-x86:shr64 :rdx 32)))))
  ;; ECX, EAX & EDX are set correctly.
  ;; If VALUE is non-constant then it'll be loaded in R8.
  (emit `(sys.lap-x86:wrmsr))
  value)

(defbuiltin sys.int::cpu-relax () ()
  (emit `(sys.lap-x86:pause))
  ;; Return no values.
  (cond ((member *for-value* '(:multiple :tail))
         (smash-r8)
         (emit `(sys.lap-x86:mov64 :r8 nil))
         (load-constant :rcx 0)
         :multiple)
        (t ''nil)))

(defbuiltin sys.int::character-array-p (object) ()
  (let ((out (gensym)))
    (load-in-reg :r8 object t)
    (smash-r8)
    ;; Check tag.
    (emit `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,out)
          `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:or8 :al ,(ash sys.int::+array-type-simple-bit+
                                      sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash sys.int::+object-tag-string+
                                       sys.int::+array-type-shift+))
          ;; Subtle. OUT can be reached through either the tag check
          ;; or through the array type check. Both checks clear ZF when
          ;; they fail.
          out)
    (predicate-result :z)))

(define-array-like-predicate sys.int::simple-character-array-p sys.int::+object-tag-simple-string+)

(defbuiltin arrayp (object) ()
  (let ((out (gensym)))
    (load-in-reg :r9 object t)
    (smash-r8)
    (emit `(sys.lap-x86:mov64 :r8 nil)
          ;; Check tag.
          `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,out)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al
                             ;; Complex arrays include simple arrays.
                             ,(ash sys.int::+last-complex-array-object-tag+
                                   sys.int::+array-type-shift+))
          `(sys.lap-x86:cmov64be :r8 (:constant t))
          out)
    (setf *r8-value* (list (gensym)))))

(defbuiltin sys.int::%complex-array-storage (complex-array) ()
  (let ((type-error (emit-type-error :r8 '(and array
                                           (not (simple-array * (*)))))))
    (load-in-reg :r8 complex-array t)
    (smash-r8)
    (emit ;; Check tag.
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-complex-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-complex-array-object-tag+
                                          sys.int::+first-complex-array-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:ja ,type-error)
          `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot 0)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::%complex-array-storage) (value complex-array) ()
  (let ((type-error (emit-type-error :r9 '(and array
                                           (not (simple-array * (*)))))))
    (load-in-reg :r8 value t)
    (load-in-reg :r9 complex-array t)
    (emit ;; Check tag.
          `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-complex-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-complex-array-object-tag+
                                          sys.int::+first-complex-array-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:ja ,type-error)
          `(sys.lap-x86:mov64 ,(object-ea :r9 :slot 0) :r8))
    value))

(defbuiltin sys.int::%complex-array-fill-pointer (complex-array) ()
  (let ((type-error (emit-type-error :r8 '(and array
                                           (not (simple-array * (*)))))))
    (load-in-reg :r8 complex-array t)
    (smash-r8)
    (emit ;; Check tag.
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-complex-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-complex-array-object-tag+
                                          sys.int::+first-complex-array-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:ja ,type-error)
          `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot 1)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::%complex-array-fill-pointer) (value complex-array) ()
  (let ((type-error (emit-type-error :r9 '(and array
                                           (not (simple-array * (*)))))))
    (load-in-reg :r8 value t)
    (load-in-reg :r9 complex-array t)
    (emit ;; Check tag.
          `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-complex-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-complex-array-object-tag+
                                          sys.int::+first-complex-array-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:ja ,type-error)
          `(sys.lap-x86:mov64 ,(object-ea :r9 :slot 1) :r8))
    value))

(defbuiltin sys.int::%complex-array-info (complex-array) ()
  (let ((type-error (emit-type-error :r8 '(and array
                                           (not (simple-array * (*)))))))
    (load-in-reg :r8 complex-array t)
    (smash-r8)
    (emit ;; Check tag.
          `(sys.lap-x86:mov8 :al :r8l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r8 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-complex-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-complex-array-object-tag+
                                          sys.int::+first-complex-array-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:ja ,type-error)
          `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot 2)))
    (setf *r8-value* (list (gensym)))))

(defbuiltin (setf sys.int::%complex-array-info) (value complex-array) ()
  (let ((type-error (emit-type-error :r9 '(and array
                                           (not (simple-array * (*)))))))
    (load-in-reg :r8 value t)
    (load-in-reg :r9 complex-array t)
    (emit ;; Check tag.
          `(sys.lap-x86:mov8 :al :r9l)
          `(sys.lap-x86:and8 :al #b1111)
          `(sys.lap-x86:cmp8 :al ,sys.int::+tag-object+)
          `(sys.lap-x86:jne ,type-error)
          ;; Check object tag.
          `(sys.lap-x86:mov8 :al ,(object-ea :r9 :slot -1))
          `(sys.lap-x86:and8 :al ,(ash (1- (ash 1 sys.int::+array-type-size+))
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:sub8 :al ,(ash sys.int::+first-complex-array-object-tag+
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:cmp8 :al ,(ash (- sys.int::+last-complex-array-object-tag+
                                          sys.int::+first-complex-array-object-tag+)
                                       sys.int::+array-type-shift+))
          `(sys.lap-x86:ja ,type-error)
          `(sys.lap-x86:mov64 ,(object-ea :r9 :slot 2) :r8))
    value))

(defbuiltin sys.int::%object-header-data (value) ()
  (load-in-reg :r8 value t)
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r8 :slot -1))
        `(sys.lap-x86:and64 :r8 ,(lognot (1- (ash 1 sys.int::+array-length-shift+))))
        `(sys.lap-x86:shr64 :r8 ,(- sys.int::+array-length-shift+
                                    sys.int::+n-fixnum-bits+)))
  (setf *r8-value* (list (gensym))))

;; FIXME: Type & limit checking here.

(defbuiltin sys.int::%complex-array-dimension (array axis) ()
  (load-in-reg :r9 axis t)
  (load-in-reg :r8 array t)
  (smash-r8)
  (emit `(sys.lap-x86:mov64 :r8 ,(object-ea :r8
                                            :slot 3
                                            :index `(:r9 ,(/ 8 (ash 1 sys.int::+n-fixnum-bits+))))))
  (setf *r8-value* (list (gensym))))

(defbuiltin (setf sys.int::%complex-array-dimension) (value array axis) ()
  (load-in-reg :r8 value t)
  (load-in-reg :r9 axis t)
  (load-in-reg :r10 array t)
  (emit `(sys.lap-x86:mov64 ,(object-ea :r10
                                        :slot 3
                                        :index `(:r9 ,(/ 8 (ash 1 sys.int::+n-fixnum-bits+))))
                            :r8))
  value)

(defbuiltin sys.int::%unbound-value () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov32 :r8d :unbound-value))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%unbound-value-p (value) ()
  (load-in-r8 value t)
  (emit `(sys.lap-x86:cmp64 :r8 :unbound-value))
  (predicate-result :e))

(defbuiltin sys.int::%unbound-tls-slot () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov32 :r8d :unbound-tls-slot))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%unbound-tls-slot-p (value) ()
  (load-in-r8 value t)
  (emit `(sys.lap-x86:cmp64 :r8 :unbound-tls-slot))
  (predicate-result :e))

(defbuiltin sys.int::%undefined-function () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov32 :r8d :undefined-function))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%undefined-function-p (value) ()
  (load-in-r8 value t)
  (emit `(sys.lap-x86:cmp64 :r8 :undefined-function))
  (predicate-result :e))

(defbuiltin sys.int::%closure-trampoline () ()
  (smash-r8)
  (emit `(sys.lap-x86:mov32 :r8d :closure-trampoline))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%closure-trampoline-p (value) ()
  (load-in-r8 value t)
  (emit `(sys.lap-x86:cmp64 :r8 :closure-trampoline))
  (predicate-result :e))

(defbuiltin sys.c::make-dx-closure (code env) (nil)
  (smash-r8)
  (let ((slots (allocate-control-stack-slots 4 t)))
    (load-in-reg :r9 code t)
    (load-in-reg :r10 env t)
    (emit `(sys.lap-x86:lea64 :rax (:stack ,(+ slots 4 -1)))
          ;; Function tag, flags and MC size.
          `(sys.lap-x86:mov32 (:rax) ,(logior #x00010000
                                              (ash sys.int::+object-tag-closure+
                                                   sys.int::+array-type-shift+)))
          ;; Constant pool size and slot count.
          `(sys.lap-x86:mov32 (:rax 4) #x00000002)
          ;; Entry point is CODE's entry point.
          `(sys.lap-x86:mov64 :rcx ,(object-ea :r9 :slot 0))
          `(sys.lap-x86:mov64 (:rax 8) :rcx)
          ;; Clear constant pool.
          `(sys.lap-x86:mov64 (:rax 16) nil)
          `(sys.lap-x86:mov64 (:rax 24) nil))
    (emit `(sys.lap-x86:lea64 :r8 (:rax ,sys.int::+tag-object+)))
    ;; Initiaize constant pool.
    (emit `(sys.lap-x86:mov64 ,(object-ea :r8 :slot 1) :r9)
          `(sys.lap-x86:mov64 ,(object-ea :r8 :slot 2) :r10)))
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::tsc () ()
  (smash-r8)
  (emit `(sys.lap-x86:rdtsc)
        ;; Pack result into one register
        `(sys.lap-x86:shl64 :rdx 32)
        `(sys.lap-x86:or64 :rax :rdx))
  (box-unsigned-byte-64-rax)
  (setf *r8-value* (list (gensym))))

(defbuiltin sys.int::%invlpg (address) ()
  (load-in-r8 address t)
  (fixnum-check :r8)
  (emit `(sys.lap-x86:mov64 :rax :r8)
        `(sys.lap-x86:sar64 :rax #.sys.int::+n-fixnum-bits+)
        `(sys.lap-x86:invlpg (:rax)))
  address)
